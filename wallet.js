const Client = require('bitcoin-core')
const assert = require('nanoassert')
const fs = require('fs')
const rgbEncode = require('../rgb-encoding/contract.js')
const { EventEmitter } = require('events')
// const utils = require('./parse-proof/index.js')

const client = new Client({
  network: 'regtest',
  username: 'node1',
  password: 'password',
  port: 18443
})

// need to import list of controlled UTXOs

// FROM KALEIDOSCOPE
	// burn
	// getNewAddress
	// issueAsset
	// sendToAddress
	// sync
	// mod



// want two wallets open, transacting with eachother and making proofs and verifying proofs?
function spend() {
  let sendto = client.getNewAddress((err, address) => {
    if (err) throw err
    return address
  })
  let newtx = client.sendToAddress(sendto, amt, (err, tx) => {
    if (err) throw err
    return tx
  })
}

// need some database of coloured UTXOs

// what is needed:
// -> make standard tx
// -> build rgb proof based on this standard tx
// -> modify tx to commit to proof

// communicate with onchain parts
class RGbHandler extends EventEmitter {
  constructor (opts = {}) {
    super()

    
  }
}

class RGbProof {
  constructor (proof) {
    this.proofID = proofId(proof)
    this.inputs = {}
    this.assets = getAssets(proof.outputs)
    this.UTXOs = getUTXOs(proof)
    this.bindTo = proof.tx.id
    this.contracts = getContracts(proof)
    this.proof = proof
  }

  // ideally have a library of proofs, and we know how many assets they have availlable, which UTXOs are spent
  // proof can be indexed by UTXO so that proofs
  // can be generated by wallet when tx is submitted.

  updateUTXOs () {
    for (let vout of Object.keys(this.UTXOs)) {
      if (UTXO.spent = true) delete this.UTXOs[vout]
    }
  }

  updateAssets () {
    getAssets(this.UTXOs)
  }


}

function getContracts (proof, contracts) {
  if (!contracts) contracts = {}
  if (!proof.contract) {
    let serializedContract = rgbEncode.contract.encode(proof.contract)
    let assetId = getIdentityHash(serializedContract).toString('hex')
    contracts[assetId] = proof.contract
  } else {
    for (input of proof.inputs) {
      getContracts(input, contracts)
    }
  }
  return contracts
}

function proofId (proof) {
  delete proof.tx
  let toHash = Buffer.from(JSON.stringify(proof))
  let identifier = getIdentityHash(toHash)
  return identifier.toString('hex')
}

function getUTXOs (proof) {
  let UTXOs = {}
  for (let output of proof.outputs) {
    let vout = output.outpoint.address
    UTXOs[vout] = output
    UTXOs[vout].spent = false
    // delete UTXOs[output.outpoint.address].outpoint
  }
  return UTXOs
}

// need a function to check which UTXOs have been spent or not.

function getAssets (outputs) {
  let assets = {}
  for (let output of outputs) {
    if (!assets[output.assetId]) assets[output.assetId] = []
    assets[output.assetId].push({
      vout: output.outpoint.address,
      amount: output.amount
    })
  }
  return assets
}


// Not actually class -> just a collection of functions
class RGbAsset {
  contructor (contract) {

    this.assetId = getIdentityHash(contract)
    this.amount = 0
    this.UTXOs = {}
    this.contract = contract

    // store latest relevant ones to each asset
    // everytime they are updated -> update all assets
    // can store proofId in the UTXOs
    this.proofs = {}
  }


  
  spendColouredUTXOs(proof) {
    for (let input of proof.inputs) {
      for (output of input.tx.output) {
        let identifier = Buffer.concat([
          Buffer.from(input.tx.id),
          Buffer.from(output)
        ])

        identifier = getIdentityHash(identifier).toString('hex')

        delete this.UTXOs[identifier]
      }
    }

    return this.UTXOs
  }

  // when a tx is spent, the UTXOs have to be updated
  getColouredUTXOs(proofId) {
    // only for address based at the moment
    let proof = this.proofs[proofId]
    let outputs = proof.outputs.filter(output =>
      output.assetId === this.assetId)

    for (let output of outputs) {

      let identifier = Buffer.concat([
        Buffer.from(proof.tx.id),
        Buffer.from(output.outpoint.address)
      ])

      identifier = getIdentityHash(identifier).toString('hex')

      this.UTXOs[identifier] = {
        amount: output.amount,
        tx: proof.tx.id,
        vout: output.outpoint.address,
        proofId: proofId
      }
    }

    return this.UTXOs
  }

  // example controlled utxo input -> something like this
  // let controlled_UTXOs = rpc_list_unspent(client)
  // controlledUTXOs = {
  //   txid1: [list of vouts],
  //   txid2: ..
  //   .
  //   .
  // }

  // now we receive a proof -> we want to add the asset to our inventory
  // based on which UTXOs we own -> this.amount should be updated
  // everytime it is spent or received, make event for this?
  amountReceived(proof, controlledUTXOs) {
    let assetOutputs = getOutputsByAsset(proof)[this.assetId].UTXOs
    let ownedAssets = assetOutputs
      .filter(UTXO => controlledUTXOs.hasOwnProperty(UTXO.tx))
      .filter(UTXO => controlledUTXOs[UTXO.tx].contains(UTXO.vout))

    let receivedAmount = ownedAssets.reduce((accumulator, UTXO) =>
      accumulator + UTXO.amount)

    return amount
  }

  // should extend this to pick the best for multiple inputs
  // return inputs array without filtering, then choose proof
  // which appears in most assets.
  selectInputs(amount) {
    assert(this.amount >= amount, 'insufficient assets')

    let inputs = Object.values(this.UTXOs)

    // look for UTXO, which satisfies asset amount exactly
    let exactInputs = inputs.filter(UTXO => UTXO.amount === amount)
    if (exactInputs.length) {
      return exactInputs[0]
    }

    // look for UTXOs that have enough assets and select the one
    // with the most assets
    let viableInputs = inputs.filter(UTXO => UTXO.amount > amount)
    if (viableInputs.length) {
      let maxInput = viableInputs.reduce((max, input) =>
        max = input.amount > max.amount ? input : max)
      return maxInput
    }

    // add the largest asset UTXOs until amount desired amount is reached
    inputs.sort((a, b) => a.amount - b.amount)
    let inputSum = 0
    let chosenInputs = []

    while (inputSum < amount) {
      if (inputs.length !== 0) {
        throw new Error('insufficient asset inputs')
      }

      let input = inputs.pop()
      chosenInputs.push(input)
      inputSum += input.amount
    }

    return inputs
  }

  pruneProofs() {
    let activeProofs = []
    for (let UTXO of this.UTXOs) {
      activeProofs.push(UTXO.proofId)
    }

    let toPrune = Object.keys(this.proofs).filter(proofId =>
      !activeProof.contains(proofId))

    while (toPrune.length != 0) {
      delete this.proofs[toPrune.pop()]
    }
  }
}

// need something that will fetch relevant proofs.
class RgbWallet extends EventEmitter {
  constructor (name, proofs, opts) {
    super()

    this.name = name
    // this.storage = opts.storage || newDirPath()
    this.rpcInfo = opts.rpcInfo

    // this should be the only class
    // in dialogue with client
    this.proofs = proofs
    this.client = new Client(this.rpcInfo)
    this.wallet = null
  }

  update () {
    const self = this
    return getAssets(self.proofs, self.client).then(assets => {
      self.wallet = assets
      self.emit('assets', assets)
      return assets
    })
  }
}

var proof1 = JSON.parse(fs.readFileSync('./proof/fixtures/new.proof'))

let proofs = [proof1]

const rpcInfoNode2 = {
  network: 'regtest',
  username: 'node1',
  password: 'password',
  port: 18443
}

const optsNode2 = {
  rpcInfo: rpcInfoNode2,
}

const wallet = new RgbWallet('node2', proofs, optsNode2)

var amounts = {
  '2e4fea47c555bde34ea7f430bfba73295a9385842228146252d5038814666c5b': 1200,
  '6d077e4aa88cb9f5ac89b720bc03ef63af29591f3c28ceb406581cc1b0e650ea': 600  
}

wallet.on('assets', () => {
  console.log(transferAsset(wallet.wallet, amounts))
})

wallet.update()


// events:
  // spend   -> asset.selectInputs(amount)
    //         -> *build proof*
    //         -> asset.spentColouredUTXOs(proof)
    //         -> remove old proof from this.proofs

  // receive -> this.amount += asset.amountReceived(proof)
    //         -> this.UTXOs.push(...getColouredUTXOs())



// RGbHandler.on('')
  // listens for newTx or proof?
  // has list of coloured outputs
  // collects relevant UTXOs for proof
  // builds proof.inputs from proofs of UTXO inputs
  // assembles proof.- 

// required functions:
function mintAsset (contract, issuanceUTXO) {
  // build contract
  let proof = {}
  // make UTXO with OP_RETURN proof.contract = contract
}
  
  
// function transferAsset (assets, amounts) {
//   // first check wallet has sufficient assets
//   for (let asset of Object.keys(amounts)) {
//     assert(assets[asset].amount >= amounts[asset],
//       'Insufficient assets')
//   }

//   // select input UTXOs
//   // this needs to be extended for multiple assets
//   var candidates = {}
//   for (const asset of Object.keys(amounts)) {
//     const request = amounts[asset]
//     candidates[asset] = inputSelection(assets, asset, request)
//   }

//   return candidates

//   function inputSelection (assets, asset, request) {
//     for (const ownedAsset of Object.keys(assets)) {
//       // skip past not matched
//       if (ownedAsset !== asset) continue
//       const inputs = assets[ownedAsset].txList

//       // look for UTXO, which satisfies request exactly
//       let exactInputs = inputs.filter(UTXO => UTXO.amount === request )
//         if (exactInputs.length) {
//           return exactInputs[0]
//         }

//       // look for UTXOs that have enough assets and select the one
//       // with the most assets
//       let viableInputs = inputs.filter(UTXO => UTXO.amount > request)
//       if (viableInputs.length) {
//         let maxInput = viableInputs.reduce((max, input) =>
//           max = input.amount > max.amount ? input : max)
//         return maxInput
//       }

//       // add UTXOs with most assets until request is satisfied
//       inputs.sort((a, b) => a.amount - b.amount)
//       let inputSum = 0
//       let chosenInputs = []

//       while (inputSum < request) {
//         let input = inputs.pop()
//         chosenInputs.push(input)
//         inputSum += input.amount
//       }
//       return chosenInputs
//     }
//   }
// }

function transferAsset (assets, amounts) {
  // first check wallet has sufficient assets
  for (let asset of Object.keys(amounts)) {
    assert(assets[asset].amount >= amounts[asset],
      'Insufficient assets')
  }

  const selectedInputs = []

  const inputs = sortByUTXO(assets, Object.keys(amounts))

  let multiAssetInputs = Object.keys(inputs).filter((item) =>
    inputs[item].length > 1)

  // handle case where one UTXO has multiple relevant assets
  if (multiAssetInputs.length !== 0) {

    const selectedUTXO = multipleAssets(multiAssetInputs)
    selectedInputs.push(selectedUTXO)
    for (let asset of inputs[selectedUTXO]) {
      let diff = amounts[asset.asset] - asset.amount
      amounts[asset.asset] = diff < 0 ? 0 : diff
    }
    for (let asset of Object.keys(amounts)) {
      if (amounts[asset] === 0) delete amounts[asset]
    }
  }

  function multipleAssets (list) {
    let results = []
    for (let UTXO of list) {
      let copy = { ...amounts }
      for (let asset of inputs[UTXO]) {
        let diff = copy[asset.asset] - asset.amount
        copy[asset.asset] = diff < 0 ? 0 : diff
      }

      results[UTXO] = Object.values(copy).reduce((acc, value) =>
        acc + value, 0)
    }

    return Object.keys(results).reduce((best, next) =>
      (results.best < results.next) ? next : best)
  }

  // sort rgb inputs according to UTXO
  function sortByUTXO (assets, transfers) {

    var transactions = {}

    for (let asset of Object.keys(assets)) {
      if (!transfers.includes(asset)) continue
      let inputs = assets[asset].txList

      for (let input of inputs) {
        const label = `${input.tx}:${input.vout}`
        if (!transactions[label]) transactions[label] = []
        transactions[label].push({
          asset: asset,
          amount: input.amount
        })
      }
    }

    return transactions
  }
}
  // calculate assets available for transfer
  // make new transfer proof
  // tweak keys
  // make transfer tx

// function receiveAsset
	// index UTXO as rgb asset
	// update asset holding
	// acceptTransferProof (below)

// function acceptTransferProof
// verify integrity of proposed transfer proof


// returns list of assets and amounts together with
// the list of tx and the amount of asset each holds
function getTotalAssets (proofs) {
  const assets = {}

  // reducer function
  function arrayConcat(sum, next) {
    return sum.concat(next)
  }

  return (UTXOs) => {
    let TxIDs = UTXOs.map(item => item.txid)

    // for each proof, check if txid is in list from btc-rpc
    for (let proof of proofs) {
      if (!TxIDs.includes(proof.tx.id)) continue
      proofAssets = getAssetsByUTXO(proof)
      let amounts = Object.values(proofAssets).reduce(arrayConcat, [])

      for (let asset of amounts) {
        let assetId = asset.assetId
        let vout = Object.keys(proofAssets).find((key) =>
          proofAssets[key].includes(asset))

        if (!assets[assetId])  assets[assetId] = { txList: [] }
        
        assets[assetId].txList.push({
          tx: proof.tx.id,
          vout: vout,
          amount: asset.amount
        })

        assets[assetId].amount = assets[assetId].txList.reduce(
          (acc, entry) => acc + entry.amount, 0)
      }
    }
    return assets
  }
}

function getAssetsByUTXO (proof, assets) {
  if (!assets) assets = {}

  for (output of proof.outputs) {
    let outpoint = output.outpoint.address
    if (!assets[outpoint]) assets[outpoint] = [] 

    assets[outpoint].push({
      assetId: output.assetId,
      amount: output.amount
    })
  }
  return assets
}

var assets = {}

async function getAssets (proofs, client) {
  if (!proofs.length) return {}
  const result = await client.listUnspent()
    .then(getTotalAssets(proofs))
    .then(assets => { return assets })
    .catch(console.error)
  return result
}

// console.log(assets)
// use getUnspentTransactionOUtputs RPC call
// cross reference with database of active proofs
// return total asset count together with relevant UTXO indices